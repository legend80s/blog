{
  "name": "Legend80s.GitHub.io",
  "tagline": "Blog",
  "body": "# JavaScript 模拟 OOP 语言的 static 变量\r\n\r\n*TL;DR 直接拉到文章末尾看「重点」吧*\r\n\r\n进入正题之前，我们先抛出一个问题，JavaScript 中静态变量通常是直接定义在类上面的，那么如何通过类的实例获取它的静态变量呢，示例代码如下：\r\n\r\n```javascript\r\nclass Parent {}\r\nParent.staticProperty = 'Static property from Parent';\r\n```\r\n\r\n我们通常会尝试这么做：\r\n```javascript\r\nconst parent = new Parent();\r\nparent.staticProperty; // undefined\r\n```\r\n这种模仿传统 OOP 语言的取法，似乎很自然、很符合直觉，但是取不到静态变量 😭，因为在 JavaScript 中属性是按原型继承的，`staticProperty` 并没有定义在原型（`prototype`）上。但是一旦定义在原型上：`Parent.prototype.staticProperty = '...'`，就把它当做普通属性了，违背了静态变量的基本定义了。下面给出一种解决方法：\r\n\r\n```javascript\r\nparent.constructor.staticProperty; // 'Static property from Parent'\r\n```\r\n\r\n但此法甚为丑陋，暴露了太多底层细节，不够 Natural，不够 Intuitive，So Not elegant at all！\r\n\r\n进入正题，利用 `magic getter` 封装细节，结合上面的解决办法，我们提供一种更为优雅的解决方案，当然重点是和传统 OOP 语言静态变量的三条规则保持一致：\r\n\r\n1. 既能通过类，也能直接通过实例获取\r\n2. 支持继承\r\n3. 支持重写\r\n\r\n直接看代码吧\r\n\r\n```javascript\r\nclass Parent {\r\n  get staticProperty() {\r\n    return this.constructor.staticProperty; // late binding\r\n  }\r\n}\r\n\r\nParent.staticProperty = 'Static property from Parent';\r\n```\r\n\r\n测试代码如下：\r\n\r\n```javascript\r\nclass Parent {\r\n  get staticProperty() {\r\n    console.log('this.constructor.name:', this.constructor.name); // constructor will changed with the caller\r\n    return this.constructor.staticProperty; // late binding\r\n  }\r\n}\r\n\r\n// 规则 1.1 直接通过类获取：Static property can be accessed by class\r\nParent.staticProperty = 'Static property from Parent';\r\n\r\nconst parent = new Parent();\r\n\r\n// 规则 1.2 也能直接通过实例获取：Static property can be accessed by it's instances\r\nconsole.log('parent.staticProperty:', parent.staticProperty); // 'Static property from Parent'\r\n\r\n// Inheritance\r\nclass Child extends Parent {}\r\n\r\n// 规则 2 支持继承：Static property can be inherited\r\nconsole.log('Child.staticProperty:', Child.staticProperty); // 'Static property from Parent'\r\n\r\n// 规则 3 支持重写：Static property can be overwritten\r\nChild.staticProperty = 'Static property from Child';\r\n\r\nconst child = new Child();\r\n\r\nconsole.log('child.staticProperty:', child.staticProperty); // 'Static property from Child'\r\n```\r\n\r\nes7 支持直接在[类里面初始化静态变量](https://esdiscuss.org/topic/es7-property-initializers)，但是目前从 babel 的[编译结果](https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Cstage-2&targets=&browsers=&builtIns=false&code=class%20Counter%20%7B%0A%20%20static%20initialCount%20%3D%200%3B%0A%7D)来看，也只是把静态变量挂载在类上面，不能完全模拟 OOP 语言的静态变量。\r\n\r\n## 重点\r\n敲黑板，注意啦同学们，开始划重点啦 😀\r\n\r\n```javascript\r\nclass Parent {\r\n  get staticProperty() {\r\n    return this.constructor.staticProperty; // late binding\r\n  }\r\n}\r\n\r\nParent.staticProperty = 'Static property from Parent';\r\n```\r\n\r\n## 参考\r\n\r\n1. http://stackoverflow.com/questions/28445693/how-do-i-make-a-public-static-field-in-an-es6-class\r\n2. https://esdiscuss.org/topic/es7-property-initializers\r\n\r\n***By OpenSearch前端团队 @ 搜索事业部 @ Alibaba***",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}